## 1.switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上?为什么？



　　可以是int 基本类型或Integer 包装类型，由于，byte,short,char 都可以隐含转换为int，所以这些类型以及这些类型的包装类型也是可以的。显然long 和String 类型都不符合switch 的语法规定，并且不能被隐式转换成int 类型，所以它们不能作用于swtich 语句中。switch中可以是字符串类型,String(JDK1.7之后才可以作用在string上)，switch中可以是枚举类型(JDK1.5之后)。

　　问题一 : 为什么switch不可作用于long double float ，包括他们的包装类?

　　　　简单的回答是因为语法的规定。在实际编程中，极少有如此多的分支，以致需要使用Long类型。这样的语法规定是语言设计者的折衷考虑，并不一定特别合理，语言规范也在不停演变。但截止目前的版本，Java的Swithch分支仍然不支持Long，在这种情况下，可以采取一些办法：

　　1） 转为int类型，范例如下：

```
      final long value = System.currentTimeMillis() % 5;
      switch ( (new Long(value)).intValue() ) //注意这行
      {
         case 1 : System.err.println("One");
                  break;
         case 2 : System.err.println("Two");
                  break;　　　
      }
```

　　2) 放弃switch，改用 if/else 的写法。
　　3) 放弃switch，改用 Map。

　　补充：语言的底层实现细节有时还真不完全清楚，Java新版本中Switch添加了对String的支持，如果要支持Long，也没问题。谁知道他们是怎么想的^_^，作为语言的使用者，遵守规则即可。



## 2.Java中实现多态的机制

多态就是指一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

特点：

指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。
若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。


Java实现多态有三个必要条件：继承、重写、向上转型。

 

调用的优先级方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。

多态的实现原理

Java 里对象方法的调用是依靠类信息里的方法表实现的。

总体而言，当调用对象某个方法时，JVM查找该对象类的方法表以确定该方法的直接引用地址，有了地址后才真正调用该方法。

 

超类继承父类的方法，如果不Overriding该方法，那么调用时会指向父类的方法。如果Overrding该方法，那么指向该类的代码区。

但是超类会存有父类的方法表。

 

我们知道java程序运行时，类的相关信息放在方法区，在这些信息中有个叫方法表的区域，该表包含有该类型所定义的所有方法的信息和指向这些方法实际代码的指针。



当Bird、Cock、Parrot和CrazyParrot这四个类被加载到 Java 虚拟机之方法区后，方法区中就包含了这四个类的信息，下图示例了各个类的方法表。



从图我们可以看到Cock、Parrot和CrazyParrot的类信息方法表包含了继承自Bird的方法。CrazyParrot的方法表包含了继承自Parrot的方法。此外各个类也有自己的方法。

注意看，方法表条目指向的具体方法代码区。对于多态Overriding的方法courtship()，虽然Cock、Parrot和CrazyParrot的方法表里的courtship()条目所在位置是属于继承自Bird方法表的部分，但指向不同的方法代码区了。