## Redis数据库的原理

Redis服务器用redisServer结构体来表示，其中redisDb是一个数组，用来保存所有的数据库，dbnum代表数据库的数量(这个可以配置，默认是16)

```
struct redisServer{  

    //redisDb数组,表示服务器中所有的数据库
    redisDb *db;  

    //服务器中数据库的数量
    int dbnum;  

}; 
```

我们知道Redis是C/S结构，Redis客户端通过redisClient结构体来表示：

```
typedef struct redisClient{  

    //客户端当前所选数据库
    redisDb *db;  

}redisClient;
```

![img](http://www.micheal.wang:10020/mongo/read/5f4374ed9c5fd27c4ff5d8b4)

Redis中对每个数据库用redisDb结构体来表示：

```
typedef struct redisDb { 
    int id;         // 数据库ID标识
    dict *dict;     // 键空间，存放着所有的键值对              
    dict *expires;  // 过期哈希表，保存着键的过期时间                          
    dict *watched_keys; // 被watch命令监控的key和相应client    
    long long avg_ttl;  // 数据库内所有键的平均TTL（生存时间）     
} redisDb;
```

从代码上我们可以发现最重要的应该是`dict *dict`，它用来存放着所有的键值对。对于`dict`数据结构(哈希表)我们在上一篇也已经详细说了。一般我们将存储所有键值对的`dict`称为**键空间**

![img](http://www.micheal.wang:10020/mongo/read/5f4375b89c5fd27c4ff5d8b6)

> Redis的数据库就是使用字典(哈希表)来作为底层实现的，对**数据库的增删改查都是构建在字典(哈希表)的操作之上的**。

## 键的过期时间

Redis是基于内存，内存是比较昂贵的，容量肯定比不上硬盘的。就我们现在一台普通的机子，可能就8G内存，但硬盘随随便便都1T了。

因为我们的内存是**有限**的。所以我们**会干掉不常用的数据，保留常用的数据**。这就需要我们设置一下键的过期(生存)时间了。

- 设置键的**生存**时间可以通过`EXPIRE`或者`PEXPIRE`命令。
- 设置键的**过期**时间可以通过`EXPIREAT`或者`PEXPIREAT`命令。

其实`EXPIRE`、`PEXPIRE`、`EXPIREAT`这三个命令都是通过`PEXPIREAT`命令来实现的。

我们在redisDb结构体中还发现了`dict *expires;`属性，存放所有键过期的时间。

举个例子基本就可以理解了：

```
redis > PEXPIREAT message 1391234400000
(integer) 1
```

设置了message键的过期时间为1391234400000

既然有设置过期(生存)时间的命令，那肯定也有移除过期时间，查看剩余生存时间的命令了：

- PERSIST(移除过期时间)
- TTL(Time To Live)返回剩余生存时间，以秒为单位
- PTTL以毫秒为单位返回键的剩余生存时间

### 过期策略

上面我们已经能够了解到：过期键是保存在哈希表中了。那这些过期键到了过期的时间，就会立马被删除掉吗？？

要回答上面的问题，需要我们了解一下删除策略的知识，删除策略可分为三种

- 定时删除(对内存友好，对CPU不友好)

- - 到时间点上就把所有过期的键删除了。

- 惰性删除(对CPU极度友好，对内存极度不友好)

- - 每次从键空间取键的时候，判断一下该键是否过期了，如果过期了就删除。

- 定期删除(折中)

- - **每隔**一段时间去删除过期键，**限制**删除的执行时长和频率。

Redis采用的是**惰性删除+定期删除**两种策略，所以说，在Redis里边如果过期键到了过期的时间了，未必被立马删除的！

### 内存淘汰机制

如果定期删除漏掉了很多过期key，也没及时去查(没走惰性删除)，大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？

我们可以设置内存最大使用量，当内存使用量超出时，会施行**数据淘汰策略**。

Redis的内存淘汰机制有以下几种：

![内存淘汰机制](http://www.micheal.wang:10020/mongo/read/5f4379a89c5fd27c4ff5d8b8)内存淘汰机制

一般场景：

> 使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是**热点数据**。可以将内存最大使用量设置为热点数据占用的内存量，然后启用allkeys-lru淘汰策略，将最近最少使用的数据淘汰





















