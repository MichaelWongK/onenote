## 前置知识

为什么我们会需要服务注册与发现呢？你设想这样一个场景，你的服务部署在不同的机房、不同的机器上，监听不同的端口。现在你的客户端收到了一个请求，要发送给服务端，那么你的客户端怎么知道哪些服务端能够处理这个请求呢？<img src="https://static001.geekbang.org/resource/image/be/90/be4c280fcdb6d64cfd5fd2649cfd0990.png?wh=2262x1352" alt="img" style="zoom: 25%;" />

### 服务注册与发现模型

<img src="https://static001.geekbang.org/resource/image/3d/88/3dc0cb7a9cb57a19526d305614967a88.png?wh=2238x1352" alt="img" style="zoom: 25%;" />



需要注意的是，服务端必须要等待一段时间才能下线。因为从它通知注册中心自己要下线，到客户端收到通知，是有一段延时的，这段延时就是服务端要等待的最小时间。

## 准备

如果你们公司确实是使用了注册中心，那么你要弄清楚一些数据和信息。

· 你们用了什么中间件作为注册中心以及该中间件的优缺点。确保自己在回答“你为什么用某个中间价作为注册中心”的时候，能够综合这些优缺点来回答。

·注册中心的集群规模。读写 QPS（每秒查询率）。

·机器性能，如 CPU 和内存大小。

·最好准备一个注册中心出故障之后你排查和后续优化的案例。在讨论使用注册中心的注意事项，或者遇到过什么 Bug 的时候可以用这个案例。

### 可以尝试从这些角度把话题引到服务注册与发现这个主题上。

第一种情况，面试官**问到了某一个可以作为注册中心的中间件**。举例来说，如果你用 ZooKeeper 作为注册中心，那么如果面试官问到了 ZooKeeper，你可以主动提起你把它作为了注册中心；如果面试官问了 etcd，那么你可以主动提起 etcd 虽好，但是你用的是 ZooKeeper。这个时候面试官很有可能会继续追问你，为什么最终选择 ZooKeeper 作为注册中心，这时候说一下它的优缺点就好了。

还有一种情况，面试官**问了你微服务高可用的问题**，那么你可以把高可用的服务注册与发现作为保证整个微服务架构高可用的一个环节来叙述。

## 基本模型

常见的分组功能，就是依赖于服务端在注册的时候同时注册自己的分组信息。

<img src="https://static001.geekbang.org/resource/image/8f/64/8f249118549d96856dc7068fb919d664.png?wh=2244x1348" alt="img" style="zoom: 33%;" />



> 服务端注册的数据除了定位信息是必需的以外，剩下需要什么数据都是根据微服务框架本身的功能和业务来设计的。比如说很多微服务框架支持分组功能，那么就可以让服务端在注册的时候同时注册自己的分组信息，比如说当前节点是 VIP 节点。那么客户端在收到 VIP 请求之后就会把请求发给 VIP 节点。

> 服务注册与发现的整个模型比较简单，不过要在实践中做到高可用还是很不容易的。

## 高可用

服务注册与发现怎么保证高可用呢？高可用的服务注册与发现要围绕**注册服务端崩溃检测、客户端容错和注册中心选型**三个方面进行。

## 服务端崩溃检测

在正常情况下，服务端下线都需要通知注册中心。那么万一服务端宕机了呢？比如说运维大哥不小心一脚把服务器电源线踢掉了，服务器直接停电了。在这种情况下，服务端是没办法通知注册中心的，注册中心自然也就不会通知客户端。那么客户端就会继续把请求发送给服务端，而这些请求显然都会失败。

<img src="https://static001.geekbang.org/resource/image/ee/43/ee1e78cc51d9f3c5010c2fdf8dced843.png?wh=2244x1348" alt="img" style="zoom:25%;" />

因此为了提高可用性，需要让注册中心尽快发现服务端已经崩溃了，而后通知客户端。所以问题的关键就在于**注册中心怎么判断服务端已经崩溃了**。

上面这张图片里注意到了，服务端崩溃之后注册中心和服务端之间的心跳就无法继续保持了。所以你得出一个简单的结论：**如果注册中心和服务端之间的心跳断了，就认为服务端已经崩溃了**。

但是，如果注册中心和服务端之间的网络出现偶发性的抖动，那么心跳也会失败。此时服务端并没有真的崩溃，还活得好好的。

<img src="https://static001.geekbang.org/resource/image/1d/7e/1d5e31f804a0f70a7f48767e1774cf7e.png?wh=2238x1352" alt="img" style="zoom:25%;" />

显然，心跳断了则服务端崩溃的判断并不能成立。这时候你可能会想到能不能多发几次心跳呢？答案是可以，但是次数越多，心跳间隔越长，注册中心断定服务端已经崩溃的时间就越长。而时间越长，就有越多请求发送给服务端。万一这个时候服务端真的崩溃了，这些请求都会失败。所以这就陷入两难境地了。要么是误以为服务端崩溃，要么是误以为服务端还活着。

那么怎么走出这个窘境呢？

一方面，注册中心在和服务端进行心跳的时候失败了，就要**立刻通知客户端**该服务端已经不可用了，那么客户端就不会再发请求过来。

另外一方面，**注册中心还要继续往服务端发心跳**。如果只是偶发性的心跳失败，那么注册中心后面心跳是肯定能够连上的，这时候注册中心再通知客户端这个服务端是可用的。

<img src="https://static001.geekbang.org/resource/image/77/3b/77c80fb1519962604eae95357f260a3b.png?wh=2238x1348" alt="img" style="zoom:25%;" />

不过注册中心并不是无限制发心跳直到连接上，而是发了一段时间之后发现心跳还是失败就不再发了，这意味着注册中心认定服务端彻底崩溃了。在彻底崩溃的场景下，注册中心不需要再次通知客户端，因为在之前注册中心就已经通知过了。

所以关键词就是**心跳**，你可以这样回答。

> 影响到可用性的另一个关键点是注册中心需要尽快发现服务端宕机。在基本模型里面，如果服务端突然宕机，那么服务端是来不及通知注册中心的。所以注册中心需要有一种检测机制，判断服务端有没有崩溃。在服务端崩溃的情况下，要及时通知客户端，不然客户端就会继续把请求发送到已经崩溃的节点上。

> 这种检测就是利用心跳来进行的。当注册中心发现和服务端的心跳失败了，那么它就应该认为服务端可能已经崩溃了，就立刻通知客户端停止使用该服务端。但是这种失败可能是偶发性的失败，比如说因为网络偶尔不稳定造成的。所以注册中心要继续保持心跳。如果几次心跳都失败了，那么就可以认为服务端已经彻底不可用了。但是如果心跳再次恢复了，那么注册中心就要再次告诉客户端这个服务端是可用的。

### 升华

> 实际上，在所有有心跳机制的分布式系统里面判断节点是否崩溃都是一个棘手的问题。比如说心跳失败了要不要继续重试，是立刻重试还是间隔重试，重试的话试几次？

> 理论上来说，在心跳失败之后如果不进行重试就直接判定服务端崩溃，那么就难以处理偶发性网络不通的问题。而如果要重试，比如说在注册中心和服务端的模型里面，重试三次，而且重试间隔是十秒钟，那么注册中心确定服务端崩溃就需要三十秒。在这三十秒内，客户端估计有成千上万的请求尝试发到崩溃的服务端，结果都失败了。

这时候，面试官很自然地就会觉得不要搞重试间隔，而是直接发起连续几次重试，这时候你就要无情地击碎这种幻想。

> 如果不考虑重试间隔的话，就难以避开偶发性的失败。比如说注册中心和服务端之间网络抖动，那么第一次心跳失败之后，你立刻重试多半也是失败的，因为此时网络很可能还是不稳定。

> 所以比较好的策略是立刻重试几次，如果都失败了就再间隔一段时间继续重试。所有的重试机制实际上也是要谨慎考虑重试次数和重试间隔的，确保在业务可以接受的范围内重试成功。不过再怎么样，从服务端崩溃到客户端知道，中间总是存在一个时间误差的，这时候就**需要客户端来做容错了**。

## 客户端容错

客户端容错是指**尽量在注册中心或者服务端节点出现问题的时候，依旧保证请求能够发送到正确的服务端节点上**。

在前一个亮点里面，你已经知道从服务端崩溃到客户端最终知道是有一段延时的。在这段延时内，客户端还是会把请求发送到已经崩溃的服务端节点上。

<img src="https://static001.geekbang.org/resource/image/ed/8c/eda58e1f3958e182daee3a47e7ecb68c.png?wh=2242x1344" alt="img" style="zoom:30%;" />

所以你要紧接着前面刷的亮点继续回答，关键词是**换节点**，也就是所谓的 **failover**。

> 客户端容错第一个要考虑的是如果某个服务端节点崩溃了该怎么办。在服务端节点崩溃之后，到注册中心发现，再到客户端收到通知，是存在一段延时的，这个延时是能算出来的。在这段延时内，客户端发送请求给这个服务端节点都会失败。

> 这个时候需要客户端来做一些容错。一般的策略是客户端在发现调不通之后，应该尝试换另外一个节点进行重试。如果客户端上的服务发现组件或者负载均衡器能够根据调用结果来做一些容错的话，那么它们应该要尝试将这个节点挪出可用节点列表，在短时间内不要再使用这个节点了。后面再考虑将这个节点挪回去。

<img src="https://static001.geekbang.org/resource/image/ea/8f/eac0a80b59d9ea0be7afaeb67df9d38f.png?wh=2238x1342" alt="img" style="zoom:30%;" />

在上面那段话中，我留了两个口子。第一个是延时怎么计算，非常简单，你从图里面就能看出来。

> 最坏的情况下，延时等于服务端和注册中心心跳间隔加上注册中心通知客户端的时间。大多数时候，注册中心通知客户端都是很快的，在毫秒级以内。因此可以认为服务端和注册中心的心跳间隔就是这个延时。

第二个点就是什么时候再将这个节点挪回可用列表，在上图中就是 A 什么时候会被重新放回可用列表。

显然，如果注册中心最终发现服务端崩溃，然后通知了客户端，那么客户端就不用放回去了。等到注册中心发现服务端再次恢复了，那么注册中心会通知客户端，此时客户端更新可用节点列表就可以了。

<img src="https://static001.geekbang.org/resource/image/bd/b3/bd662b5087aaec8f7c3b24171ced4eb3.png?wh=2242x1350" alt="img" style="zoom:33%;" />

但是有一种情况是需要客户端主动检测的。这种情况就是服务端节点还活着，注册中心也还活着，唯独客户端和服务端之间的网络有问题，导致客户端调用不通。

<img src="https://static001.geekbang.org/resource/image/1e/c1/1e6f7a380e3572372f3b2a65e565a9c1.png?wh=2238x1350" alt="img" style="zoom:33%;" />

在这种情况下，类似于注册中心和服务端心跳失败，客户端也要朝着那个疑似崩溃的服务端节点继续发送心跳。如果心跳成功了，就将节点放回可用列表。如果连续几次心跳都没有成功，那么就不用放回去了，直接认为这个节点已经崩溃了。

这个分析也适用于客户端和注册中心心跳失败的场景。很显然在这种情况下，客户端可以直接使用本地缓存的可用节点列表，而后如果调不通了则处理方式完全一样。但是不同的是，如果客户端长期连不上注册中心，那么客户端本身应该考虑整个退出。

## 注册中心选型

注册中心选型类似于其他中间件选型，要考虑的因素非常多。比如说中间件成熟度、社区活跃度、性能等因素。相比之下，注册中心更加关注 CAP 中选 CP 还是选 AP 的问题。

> C：Consistency，数据一致性
>
> A：Availability，服务可用性
>
> P：Partition-tolerance，分区容错
>
> CAP 理论告诉我们，一个分布式系统不可能同时满足数据一致性、服务可用性和分区容错性这三个基本需求，最多只能同时满足其中的两个。——来自[《深入浅出分布式原理》](https://time.geekbang.org/column/article/481069?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_term=guanwang&utm_campaign=guanwang&utm_content=0511)

简单来说，选择 CP 就是选了一致性和分区容错性，而选择 AP 就相当于选了可用性和分区容错性。

看上去 P 分区容错性是肯定要选的，那么剩下的就是选 C（一致性） 还是选 A（可用性） 了。那么你要先理解在注册中心选型里面，一致性和可用性究竟哪个更加重要？标准答案是可用性，也就意味着 CP 和 AP 你应该选 AP。

前面我们讨论了客户端容错，那么显然在选择 AP 的情况下，客户端就可能拿到错误的可用节点列表。如果客户端将请求发到错误的可用节点上，就会出现错误，此时客户端自然可以执行容错，换一个可用节点重试。

所以我们要抓住关键词**客户端容错**进行回答。

> 在注册中心选型上，重要的是 CAP 原理中应该选择 AP，比如说 Eureka，又或者 Nacos 启用 AP 模式。

万一你公司并没有使用 AP 模型的注册中心，比如说用了 CP 模型的 ZooKeeper，那么你就可以进一步解释，关键词是**体量小**。

> 我司之所以用 ZooKeeper，主要是因为我司体量小，集群规模也不大，ZooKeeper 虽然不是 AP 的，但是在这种体量下也够用了。不过我也尝试在公司内部推动看能否换一个中间件，比如说用 Nacos 的 AP 模式。

## 思路总结

这节课我们主要解决的是服务注册与发现的问题。我给出了基本的服务注册与发现模型，然后从服务端崩溃检测、客户端容错、注册中心选型三个角度来保证了服务注册与发现的高可用。其中我提到了几个关键词，分别是**注册数据、分组、心跳、换节点、客户端容错、体量小**。你可以从这几个关键词出发，根据自己的项目经验，梳理思路。

最后我再提醒一下，如果你觉得服务注册与发现实在难以记忆，可以**把整个模型想成是一个三角形，而解决高可用问题的关键就是这个三角形任何一条边出问题了该怎么办**。我非常建议你画一画这个三角形，并且手写一下你能想到的各种容错措施。

![img](https://static001.geekbang.org/resource/image/yy/07/yy1e0ab00fc4b83c15f400ca71e03b07.jpg?wh=2360x1855)



## 提问

1. 如果注册中心崩溃了，你的系统会怎么样？

 		注册中心崩溃之后，相当于三角形里面客户端与注册中心、服务端与注册中心这两条线断掉了。 对服务端的影响就是，服务端上线和下线没法通知到客户端。 对客户端的影响是，客户端没法更新可用服务端列表，只能使用本地现有的可用服务端列表，勉强维持服务。 

2. 再列举一个心跳频率、心跳重试机制对系统可用性影响的例子？

 		心跳频率过长，会增加系统判断故障的延迟；如果心跳频率过短，又会增加系统负载和网络流量，造成系统资源的过度消耗。需要在系统负载和实时性要求之间做权衡，选择合适的心跳频率。 心跳重试机制，避免了偶发性的网络抖动造成的故障误判，但同时也变相增加了判断故障的延迟。重试次数、间隔设计不合理，同样会造成系统资源的过度消耗。









